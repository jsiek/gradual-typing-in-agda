\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{Peter Thiemann's Festschrift 2024} % Name of the event you are submitting to

\usepackage{iftex}

\ifpdf
  \usepackage{underscore}         % Only needed if you use pdflatex.
  \usepackage[T1]{fontenc}        % Recommended with pdflatex
\else
  \usepackage{breakurl}           % Not needed if you use pdflatex only.
\fi

\usepackage{fancyvrb}
\usepackage{agda}
%\usepackage{mathabx}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage[numbers]{natbib}
%\usepackage{nath}

%% \usepackage{ucs}
%% \usepackage[utf8x]{inputenc}
%% \usepackage{autofe}
\usepackage{newunicodechar}
\newunicodechar{‚à∑}{{::}}
\newunicodechar{‚ä§}{\ensuremath{\top}}
\newunicodechar{‚ä•}{\ensuremath{\bot}}
\newunicodechar{‚ÇÅ}{\ensuremath{_1}}
\newunicodechar{‚ÇÇ}{\ensuremath{_2}}
\newunicodechar{‚ÇÉ}{\ensuremath{_3}}

\newunicodechar{Œ≤}{\ensuremath{\beta}}
\newunicodechar{Œ≥}{\ensuremath{\gamma}}
\newunicodechar{Œª}{\ensuremath{\lambda}}
\newunicodechar{Œõ}{\ensuremath{\Lambda}}
\newunicodechar{Œº}{\ensuremath{\mu}}
\newunicodechar{ŒΩ}{\ensuremath{\nu}}
\newunicodechar{œÅ}{\ensuremath{\rho}}
\newunicodechar{œÉ}{\ensuremath{\sigma}}
\newunicodechar{Œ†}{\ensuremath{\Pi}}
\newunicodechar{Œæ}{\ensuremath{\xi}}
\newunicodechar{Œì}{\ensuremath{\Gamma}}
\newunicodechar{Œî}{\ensuremath{\Delta}}
\newunicodechar{Œ£}{\ensuremath{\Sigma}}

\newunicodechar{‚àÄ}{\ensuremath{\forall}}
\newunicodechar{‚àÉ}{\ensuremath{\exists}}
\newunicodechar{‚äé}{\ensuremath{\uplus}}
\newunicodechar{·µñ}{\ensuremath{^p}}
\newunicodechar{‚â°}{\ensuremath{\equiv}}
\newunicodechar{‚â¢}{\ensuremath{\not\equiv}}
\newunicodechar{‚äë}{\ensuremath{\sqsubseteq}}
\newunicodechar{‚òÖ}{\ensuremath{\star}}
\newunicodechar{‚àº}{\ensuremath{\sim}}
\newunicodechar{‚åà}{\ensuremath{\lceil}}
\newunicodechar{‚åâ}{\ensuremath{\rceil}}
\newunicodechar{¬∑}{\ensuremath{\cdot}}
\newunicodechar{‚Ä¢}{\ensuremath{\bullet}}

\newunicodechar{‚áí}{\ensuremath{\Rightarrow}}
\newunicodechar{‚Ü†}{\ensuremath{\longrightarrow^{*}}}
\newunicodechar{‚áì}{\ensuremath{\Downarrow}}
\newunicodechar{‚áë}{\ensuremath{\Uparrow}}
\newunicodechar{‚ü∂}{\ensuremath{\longrightarrow}}

\newunicodechar{Œπ}{\ensuremath{\iota}}
\newunicodechar{‚Çú}{\ensuremath{_t}}
\newunicodechar{‚ä¢}{\ensuremath{\vdash}}
\newunicodechar{‚ä©}{\ensuremath{\Vdash}}
\newunicodechar{‚ä®}{\ensuremath{\vDash}}
\newunicodechar{‚¶Ç}{\ensuremath{\mathop{:}}}
\newunicodechar{‚àà}{\ensuremath{\in}}
\newunicodechar{‚àã}{\ensuremath{\ni}}
\newunicodechar{‚Ä≤}{\ensuremath{'}}
\newunicodechar{‚Ä≥}{\ensuremath{''}}
\newunicodechar{∆õ}{\ensuremath{\lambda}}
\newunicodechar{‚âº}{\ensuremath{\preceq}}
\newunicodechar{‚âΩ}{\ensuremath{\succeq}}
\newunicodechar{·µ•}{\ensuremath{_v}}
\newunicodechar{À¢}{\ensuremath{^s}}
\newunicodechar{‚àÖ}{\ensuremath{\emptyset}}
\newunicodechar{‚à£}{\ensuremath{|}}
\newunicodechar{·¥∏}{\ensuremath{^L}}
\newunicodechar{·¥ø}{\ensuremath{^R}}
\newunicodechar{‚ñ∑}{\ensuremath{\triangleright}}
\newunicodechar{·µç}{\ensuremath{^g}}
\newunicodechar{·µí}{\ensuremath{^{\circ}}}
\newunicodechar{‚©¶}{\ensuremath{\equiv}}
\newunicodechar{‚àé}{\ensuremath{\blacksquare}}
\newunicodechar{‚ñ°}{\ensuremath{\square}}
\newunicodechar{‚ñ†}{\ensuremath{\blacksquare}}
\newunicodechar{‚áî}{\ensuremath{\iff}}
\newunicodechar{ùí±}{\ensuremath{\mathcal{V}}}
\newunicodechar{Ã¨}{}
\newunicodechar{ùí´}{\ensuremath{\mathcal{P}}}
\newunicodechar{‚Ñ∞}{\ensuremath{\mathcal{E}}}
\newunicodechar{‚â§}{\ensuremath{\leq}}

\newunicodechar{‚Ñï}{\ensuremath{\mathbb{N}}}
\newunicodechar{ùîπ}{\ensuremath{\mathbb{B}}}

\newunicodechar{‚¶â}{\ensuremath{\llfloor}}
\newunicodechar{‚¶ä}{\ensuremath{\rrfloor}}
\newunicodechar{‚ü¶}{\ensuremath{[}}
\newunicodechar{‚üß}{\ensuremath{]}}
\newunicodechar{‚¶Ö}{\ensuremath{\llparenthesis}}
\newunicodechar{‚¶Ü}{\ensuremath{\rrparenthesis}}
\newunicodechar{‚ü™}{\ensuremath{\langle\!\!\langle}}
\newunicodechar{‚ü´}{\ensuremath{\rangle\!\!\rangle}}
\newunicodechar{‚ü®}{\ensuremath{\langle}}
\newunicodechar{‚ü©}{\ensuremath{\rangle}}
\newunicodechar{‚à∂}{:}
\newunicodechar{‚®ü}{\ensuremath{\fatsemi}}
\newunicodechar{‚Üë}{\ensuremath{\uparrow}}
\newunicodechar{‚â†}{\ensuremath{\neq}}

%% \DefineVerbatimEnvironment
%%   {code}{Verbatim}
%%   {} % Add fancy options here if you like.

\title{Gradual Guarantee via \\ Step-Indexed Logical Relations in Agda}
\author{Jeremy G. Siek
\institute{School of Informatics, Computing, and Engineering\\
Indiana University \\
Bloomington, IN, USA}
\email{jsiek@iu.edu}
%% \and
%% Co Author \qquad\qquad Yet S. Else
%% \institute{Stanford University\\
%% California, USA}
%% \email{\quad is@gmail.com \quad\qquad somebody@else.org}
}
\def\titlerunning{Gradual Guarantee via Step-Indexed Logical Relations in Agda}
\def\authorrunning{Jeremy G. Siek}
\begin{document}
\maketitle

\begin{abstract}
  The gradual guarantee is an important litmus test for gradually
  typed languages, that is, languages that enable a mixture of static
  and dynamic typing. The gradual guarantee states that changing the
  precision of a type annotation does not change the behavior of the
  program, except perhaps to trigger an error if the type annotation
  is incorrect. Siek et al. (2015) proved that the Gradually Typed
  Lambda Calulus (GTLC) satisfies the gradual guarantee using a
  simulation-based proof and mechanized their proof in Isabelle. In
  the following decade, researchers have proved the gradual guarantee
  for more sophisticated calculi, using step-indexed logical
  relations.  However, given the complexity of that style of proof,
  there has not yet been a mechanized proof of the gradual guarantee
  using step-indexed logical relations. This paper reports on a
  mechanized proof of the gradual guarantee for the GTLC carried out
  in the Agda proof assistant.
\end{abstract}

\section{Introduction}

Gradually typed languages introduce the unknown type ‚òÖ as a way for
programmers to control the amount of type precision, and compile-time
type checking, in their program \cite{Siek:2006bh,Siek:2007qy}. If all
type annotations are just ‚òÖ, then the program behaves like a
dynamically typed language. At the other end of the spectrum, if no
type annotation contains ‚òÖ, then the program behaves like a statically
typed language.

Siek et al.~\cite{Siek:2015ac} introduce the \emph{gradual guarantee}
as a litmus test for gradually typed languages.  This property says
that the behavior of a program should not change (except for errors)
when the programmer changes type annotations to be more or less
precise.  Siek et al.~\cite{Siek:2015ac} prove that the Gradually
Typed Lambda Calculus (GTLC) satisfies the gradual guarantee using a
simulation-based proof and mechanize the result in the Isabelle proof
assistant~\cite{Nipkow:2002jl}. Using logical relations, New and
Ahmed~\cite{New:2018aa} prove the gradual guarantee for the GTLC and
New et al.~\cite{New:2019ab} prove the gradual guarantee for a
polymorphic calculus. Several researchers apply logical relations to
prove other properties of gradually typed languages, such as
noninterference\cite{Toro:2018aa},
parametricity~\cite{Ahmed:2011fk,New:2019ab,Labrada:2020tk}, and fully
abstract embedding~\cite{Jacobs:2021aa}. Of all this later work, only
the fully abstract embedding was mechanized in a proof assistant (in
Coq~\cite{The-Coq-Development-Team:2004kf} using the Iris
framework~\cite{JUNG:2018aa}.)

There are several technical challenges to overcome in developing a
mechanized proof of the gradual guarantee using step-indexed logical
relations. As in any programming language mechanization, one must
choose how to represent variables and perform substitution. Moreover,
proofs based on logical relations rely on the fact that substitutions
commute, and the proof of this standard result is quite technical and
lengthy. Repeating these proofs for each new programming language is
quite tedious, but this metatheory can be developed in a
language-independent way using the notion of \emph{abstract binding
  trees}~\cite{Harper:2012aa}. To this end we developed the Abstract
Binding Tree library in Agda~\cite{Siek:2021to}, representing
variables as de Bruijn indices and implementing substitution via
parallel renaming and
substitution~\cite{McBride:2005aa,Wadler:2020aa}.

The second technical challenge is that step-indexed logical relations
``involve tedious, error-prone, and proof-obscuring step-index
arithmetic''~\cite{Dreyer:2011wl}. Dreyer, Ahmed, and
Birkedal~\cite{Dreyer:2011wl} propose to abstract over the
step-indexing using a modal logic named LSLR. Dreyer and Birkedal,
with many colleagues, implemented this logic as part of the Iris
framework~\cite{JUNG:2018aa} in the Coq proof assistant. To make a
similar modal logic available in the Agda proof assistant, we
developed the Step-Indexed Logic (SIL) library~\cite{Siek:2023aa}.
The proof of the gradual guarantee in this paper is the first
application of SIL and we report on the experience.

The semantics of the GTLC is defined by translation to a Cast
Calculus, so we present the Cast Calculus in
Section~\ref{sec:cast-calculus}. We define the precision relation on
types and terms in Section~\ref{sec:precision} and we review
Step-Indexed Logic in Section~\ref{sec:SIL}.  We define a logical
relation for precision in Section~\ref{sec:log-rel}. We prove the
Fundamental Theorem of the logical relation in
Section~\ref{sec:fundamental}, which is the main technical result of
this paper. To finish the proof of the gradual guarantee, in
Section~\ref{sec:gradual-guarantee} we prove that the logical relation
implies semantic approximation and semantic approximation implies the
gradual guarantee. Section~\ref{sec:conclusion} concludes this paper.

\input{PeterCastCalculus}
\input{PeterFestschrift}
\input{PeterFundamental}
\input{PeterGG}

\section{Conclusion}



%\nocite{*}
\bibliographystyle{eptcs}
\bibliography{all}
\end{document}
