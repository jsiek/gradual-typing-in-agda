\documentclass[submission,copyright,creativecommons]{eptcs}
\providecommand{\event}{Peter Thiemann's Festschrift 2024} % Name of the event you are submitting to

\usepackage{iftex}

\ifpdf
  \usepackage{underscore}         % Only needed if you use pdflatex.
  \usepackage[T1]{fontenc}        % Recommended with pdflatex
\else
  \usepackage{breakurl}           % Not needed if you use pdflatex only.
\fi

\usepackage{fancyvrb}
\usepackage{agda}
%\usepackage{mathabx}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage[numbers]{natbib}
%\usepackage{nath}

%% \usepackage{ucs}
%% \usepackage[utf8x]{inputenc}
%% \usepackage{autofe}
\usepackage{newunicodechar}
\newunicodechar{‚à∑}{{::}}
\newunicodechar{‚ä§}{\ensuremath{\top}}
\newunicodechar{‚ä•}{\ensuremath{\bot}}
\newunicodechar{‚ÇÅ}{\ensuremath{_1}}
\newunicodechar{‚ÇÇ}{\ensuremath{_2}}
\newunicodechar{‚ÇÉ}{\ensuremath{_3}}

\newunicodechar{Œ≤}{\ensuremath{\beta}}
\newunicodechar{Œ≥}{\ensuremath{\gamma}}
\newunicodechar{Œª}{\ensuremath{\lambda}}
\newunicodechar{Œõ}{\ensuremath{\Lambda}}
\newunicodechar{Œº}{\ensuremath{\mu}}
\newunicodechar{ŒΩ}{\ensuremath{\nu}}
\newunicodechar{œÅ}{\ensuremath{\rho}}
\newunicodechar{œÉ}{\ensuremath{\sigma}}
\newunicodechar{Œ†}{\ensuremath{\Pi}}
\newunicodechar{Œæ}{\ensuremath{\xi}}
\newunicodechar{Œì}{\ensuremath{\Gamma}}
\newunicodechar{Œî}{\ensuremath{\Delta}}
\newunicodechar{Œ£}{\ensuremath{\Sigma}}

\newunicodechar{‚àÄ}{\ensuremath{\forall}}
\newunicodechar{‚àÉ}{\ensuremath{\exists}}
\newunicodechar{‚äé}{\ensuremath{\uplus}}
\newunicodechar{·µñ}{\ensuremath{^p}}
\newunicodechar{‚â°}{\ensuremath{\equiv}}
\newunicodechar{‚â¢}{\ensuremath{\not\equiv}}
\newunicodechar{‚äë}{\ensuremath{\sqsubseteq}}
\newunicodechar{‚òÖ}{\ensuremath{\star}}
\newunicodechar{‚àº}{\ensuremath{\sim}}
\newunicodechar{‚åà}{\ensuremath{\lceil}}
\newunicodechar{‚åâ}{\ensuremath{\rceil}}
\newunicodechar{¬∑}{\ensuremath{\cdot}}
\newunicodechar{‚Ä¢}{\ensuremath{\bullet}}

\newunicodechar{‚áí}{\ensuremath{\Rightarrow}}
\newunicodechar{‚Ü†}{\ensuremath{\longrightarrow^{*}}}
\newunicodechar{‚áì}{\ensuremath{\Downarrow}}
\newunicodechar{‚áë}{\ensuremath{\Uparrow}}
\newunicodechar{‚ü∂}{\ensuremath{\longrightarrow}}

\newunicodechar{Œπ}{\ensuremath{\iota}}
\newunicodechar{‚Çú}{\ensuremath{_t}}
\newunicodechar{‚ä¢}{\ensuremath{\vdash}}
\newunicodechar{‚ä©}{\ensuremath{\Vdash}}
\newunicodechar{‚ä®}{\ensuremath{\vDash}}
\newunicodechar{‚¶Ç}{\ensuremath{\mathop{:}}}
\newunicodechar{‚àà}{\ensuremath{\in}}
\newunicodechar{‚àã}{\ensuremath{\ni}}
\newunicodechar{‚Ä≤}{\ensuremath{'}}
\newunicodechar{‚Ä≥}{\ensuremath{''}}
\newunicodechar{∆õ}{\ensuremath{\lambda}}
\newunicodechar{‚âº}{\ensuremath{\preceq}}
\newunicodechar{‚âΩ}{\ensuremath{\succeq}}
\newunicodechar{·µ•}{\ensuremath{_v}}
\newunicodechar{À¢}{\ensuremath{^s}}
\newunicodechar{‚àÖ}{\ensuremath{\emptyset}}
\newunicodechar{‚à£}{\ensuremath{|}}
\newunicodechar{·¥∏}{\ensuremath{^L}}
\newunicodechar{·¥ø}{\ensuremath{^R}}
\newunicodechar{‚ñ∑}{\ensuremath{\triangleright}}
\newunicodechar{·µç}{\ensuremath{^g}}
\newunicodechar{·µí}{\ensuremath{^{\circ}}}
\newunicodechar{‚©¶}{\ensuremath{\equiv}}
\newunicodechar{‚àé}{\ensuremath{\blacksquare}}
\newunicodechar{‚ñ°}{\ensuremath{\square}}
\newunicodechar{‚ñ†}{\ensuremath{\blacksquare}}
\newunicodechar{‚áî}{\ensuremath{\iff}}
\newunicodechar{ùí±}{\ensuremath{\mathcal{V}}}
\newunicodechar{Ã¨}{}
\newunicodechar{ùí´}{\ensuremath{\mathcal{P}}}
\newunicodechar{‚Ñ∞}{\ensuremath{\mathcal{E}}}
\newunicodechar{‚â§}{\ensuremath{\leq}}

\newunicodechar{‚Ñï}{\ensuremath{\mathbb{N}}}
\newunicodechar{ùîπ}{\ensuremath{\mathbb{B}}}

\newunicodechar{‚¶â}{\ensuremath{\llfloor}}
\newunicodechar{‚¶ä}{\ensuremath{\rrfloor}}
\newunicodechar{‚ü¶}{\ensuremath{[}}
\newunicodechar{‚üß}{\ensuremath{]}}
\newunicodechar{‚¶Ö}{\ensuremath{\llparenthesis}}
\newunicodechar{‚¶Ü}{\ensuremath{\rrparenthesis}}
\newunicodechar{‚ü™}{\ensuremath{\langle\!\!\langle}}
\newunicodechar{‚ü´}{\ensuremath{\rangle\!\!\rangle}}
\newunicodechar{‚ü®}{\ensuremath{\langle}}
\newunicodechar{‚ü©}{\ensuremath{\rangle}}
\newunicodechar{‚à∂}{:}
\newunicodechar{‚®ü}{\ensuremath{\fatsemi}}
\newunicodechar{‚Üë}{\ensuremath{\uparrow}}
\newunicodechar{‚â†}{\ensuremath{\neq}}

%% \DefineVerbatimEnvironment
%%   {code}{Verbatim}
%%   {} % Add fancy options here if you like.

\title{Gradual Guarantee via \\ Step-Indexed Logical Relations in Agda}
\author{Jeremy G. Siek
\institute{School of Informatics, Computing, and Engineering\\
Indiana University \\
Bloomington, IN, USA}
\email{jsiek@iu.edu}
%% \and
%% Co Author \qquad\qquad Yet S. Else
%% \institute{Stanford University\\
%% California, USA}
%% \email{\quad is@gmail.com \quad\qquad somebody@else.org}
}
\def\titlerunning{Gradual Guarantee via Step-Indexed Logical Relations in Agda}
\def\authorrunning{Jeremy G. Siek}
\begin{document}
\maketitle

\begin{abstract}
  The gradual guarantee is an important litmus test for gradually
  typed languages, that is, languages that enable a mixture of static
  and dynamic typing. The gradual guarantee states that changing the
  precision of a type annotation does not change the behavior of the
  program, except perhaps to trigger an error if the type annotation
  is incorrect. Siek et al. (2015) proved that the Gradually Typed
  Lambda Calculus (GTLC) satisfies the gradual guarantee using a
  simulation-based proof and mechanized their proof in Isabelle. In
  the following decade, researchers have proved the gradual guarantee
  for more sophisticated calculi, using step-indexed logical
  relations.  However, given the complexity of that style of proof,
  there has not yet been a mechanized proof of the gradual guarantee
  using step-indexed logical relations. This paper reports on a
  mechanized proof of the gradual guarantee for the GTLC carried out
  in the Agda proof assistant.
\end{abstract}

\section{Introduction}

Gradually typed languages introduce the unknown type ‚òÖ as a way for
programmers to control the amount of type precision, and compile-time
type checking, in their program \cite{Siek:2006bh,Siek:2007qy}. If all
type annotations are just ‚òÖ, then the program behaves like a
dynamically typed language. At the other end of the spectrum, if no
type annotation contains ‚òÖ, then the program behaves like a statically
typed language.

Siek et al.~\cite{Siek:2015ac} introduce the \emph{gradual guarantee}
as a litmus test for gradually typed languages.  This property says
that the behavior of a program should not change (except for errors)
when the programmer changes type annotations to be more or less
precise.  Siek et al.~\cite{Siek:2015ac} prove that the Gradually
Typed Lambda Calculus (GTLC) satisfies the gradual guarantee using a
simulation-based proof and mechanize the result in the Isabelle proof
assistant~\cite{Nipkow:2002jl}. Using logical relations, New and
Ahmed~\cite{New:2018aa} prove the gradual guarantee for the GTLC and
New et al.~\cite{New:2019ab} prove the gradual guarantee for a
polymorphic calculus. Several researchers apply logical relations to
prove other properties of gradually typed languages, such as
noninterference\cite{Toro:2018aa},
parametricity~\cite{Ahmed:2011fk,New:2019ab,Labrada:2020tk}, and fully
abstract embedding~\cite{Jacobs:2021aa}. Of this later work, only the
abstract embedding was mechanized (in
Coq~\cite{The-Coq-Development-Team:2004kf} using the Iris
framework~\cite{JUNG:2018aa}.)

There are several technical challenges to overcome in developing a
mechanized proof of the gradual guarantee using step-indexed logical
relations. As in any programming language mechanization, one must
choose how to represent variables and perform substitution. Moreover,
proofs based on logical relations rely on the fact that substitutions
commute, and the proof of this standard result is quite technical and
lengthy. Repeating these proofs for each new programming language is
quite tedious, but this metatheory can be developed in a
language-independent way using the notion of \emph{abstract binding
  trees}~\cite{Harper:2012aa}. To this end we developed the Abstract
Binding Tree library in Agda~\cite{Siek:2021to}, representing
variables as de Bruijn indices and implementing substitution via
parallel renaming and
substitution~\cite{McBride:2005aa,Wadler:2020aa}.

The second technical challenge is that step-indexed logical relations
``involve tedious, error-prone, and proof-obscuring step-index
arithmetic''~\cite{Dreyer:2011wl}. Dreyer, Ahmed, and
Birkedal~\cite{Dreyer:2011wl} propose to abstract over the
step-indexing using a modal logic named LSLR. Dreyer and Birkedal,
with many colleagues, implemented this logic as part of the Iris
framework~\cite{JUNG:2018aa} in the Coq proof assistant. To make a
similar modal logic available in Agda, we developed the Step-Indexed
Logic (SIL)~\cite{Siek:2023aa}.  The proof of the gradual guarantee in
this paper is the first application of SIL and we report on the
experience.

The semantics of the GTLC is defined by translation to a Cast
Calculus, so we present the Cast Calculus in
Section~\ref{sec:cast-calculus}. We define the precision relation on
types and terms in Section~\ref{sec:precision} and we review
Step-Indexed Logic in Section~\ref{sec:SIL}.  We define a logical
relation for precision in Section~\ref{sec:log-rel}. We prove the
Fundamental Theorem of the logical relation in
Section~\ref{sec:fundamental}. To finish the proof of the gradual
guarantee, in Section~\ref{sec:gradual-guarantee} we prove that the
logical relation implies the gradual
guarantee. Section~\ref{sec:conclusion} concludes this paper with a
comparison of using logical-relations versus simulation to prove the
gradual guarantee and it acknowledges Peter Thiemann and Philip Wadler
for their contributions to this work.


\input{PeterCastCalculus}
\input{PeterFestschrift}
\input{PeterFundamental}
\input{PeterGG}

\section{Conclusion and Acknowledgments}
\label{sec:conclusion}

This paper presented the first mechanized proof of the gradual
guarantee using step-indexed logical relations. One naturally wonders
how using step-indexed logical relations compares to a
simulation-based proof. One rough comparison is the number of lines of
code in Agda. Wadler, Thiemann, and I developed a simulation-based
proof of the gradual guarantee for a similar cast calculus in Agda,
which came in at 3,200 LOC. The logical-relations proof presented here
was significantly shorter, at 2,300 LOC, though it makes use of the
Abstract Binding Tree Library (900 LOC) and the Step-Indexed Logic
Library (2100 LOC). These LOC numbers confirm my feeling that the
total effort to create the SIL and ABT libraries and prove the gradual
guarantee via logical relations was higher than to prove the gradual
guarantee via simulation. However, if one discounts the SIL and ABT
libraries because they are reusable and language independent, then the
remaining effort to prove the gradual guarantee via logical relations
was lower than via simulation.

As mentioned at various points in this paper, there are some rough
edges to the SIL and ABT libraries, primarily due to challenges
regarding ``leaky abstractions''. For SIL, we mentioned how Agda's
output shows normalized versions of the SIL formulas, which exposes
the underlying encodings and are too large to be readable. We have
created a new version of SIL that uses Agda's \texttt{abstract}
feature and look forward to updating the proof of the gradual
guarantee to use the new version of SIL. Regarding the ABT library,
there are also challenges regarding (1) Agda output not always using
the concise pattern syntax and (2) Agda's automated case splitting
does not work for ABT-generated languages.

This work was conducted in the context of a collaboration with Peter
Thiemann and Philip Wadler where we have been exploring how to
mechanize blame calculi in Agda and study the polymorphic blame
calculus. My understanding of step-indexed logical relations was
improved by reading Peter Thiemann's proof in Agda of type safety for
a typed $\lambda$-calculus with \textsf{fix} using step-indexed
logical relations. The initiative to build an Agda version of the LSLR
logic came from Philip Wadler.


%\nocite{*}
\bibliographystyle{eptcs}
\bibliography{all}
\end{document}

% LocalWords:  Siek al GTLC Isabelle Agda Ahmed parametricity Coq de
% LocalWords:  metatheory Bruijn Dreyer Birkedal LSLR SIL Wadler LOC
% LocalWords:  Thiemann ABT Agda's Thiemann's
