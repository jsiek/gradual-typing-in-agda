\begin{code}[hide]
{-# OPTIONS --rewriting #-}
module LogRel.PeterLogRel where

open import Data.Empty using (‚ä•; ‚ä•-elim)
open import Data.List using (List; []; _‚à∑_; map; length)
open import Data.Nat
open import Data.Nat.Properties
open import Data.Bool using (true; false) renaming (Bool to ùîπ)
open import Data.Product using (_,_;_√ó_; proj‚ÇÅ; proj‚ÇÇ; Œ£-syntax; ‚àÉ-syntax)
open import Data.Sum using (_‚äé_; inj‚ÇÅ; inj‚ÇÇ)
open import Data.Unit using (‚ä§; tt)
open import Data.Unit.Polymorphic renaming (‚ä§ to top·µñ; tt to tt·µñ)
open import Relation.Binary.PropositionalEquality as Eq
  using (_‚â°_; _‚â¢_; refl; sym; cong; subst; trans)
open import Relation.Nullary using (¬¨_; Dec; yes; no)

open import Var
open import Sig
open import LogRel.PeterCastCalculus
open import LogRel.PeterPrecision
open import StepIndexedLogic
\end{code}

\section{Step-Indexed Logic}
\label{sec:SIL}

The Step-Indexed Logic (SIL) library~\cite{Siek:2023aa} is a shallow
embedding of a modal logic into Agda. The formulas of this logic have
type \textsf{Set·µí}, which is a record with three fields, the most
important of which is named \textsf{\#} and is a function from ‚Ñï to
\textsf{Set} which expresses the meaning of the formula in Agda.
Think of the ‚Ñï as a count-down clock, with smaller numbers
representing later points in time. The other two fields of the record
contain proofs of the LSLR invariants: (1) that the formula is true at
0, and (2) if the formula is true at some number, then it is true at
all smaller numbers (monotonicity). Each of the constructors for SIL
formulas proves these two properties, thereby saving the client of SIL
from these tedious proofs.

SIL includes the connectives of first-order logic (conjunction,
disjunction, existential and universal quantification, etc.).  Each
connective comes in two versions, one with a superscript ``o'' and
another with superscript ``s''. The ``o'' version has type
\textsf{Set·µí} whereas the ``s'' version has type
$\mathsf{Set}À¢\,Œì\,Œî$, which we explain next. What makes SIL special
is that it includes an operator Œº·µí for defining recursive
predicates. In the body of the Œº·µí, de Bruijn index 0 refers to itself,
that is, the entire Œº·µí. However, variable 0 may only be used
``later'', that is, underneath at least one use of the modal operator
‚ñ∑À¢.  The formula in the body of a Œº·µí has type $\mathsf{Set}À¢\,Œì\,Œî$,
where $Œì$ is a list of types, one for each recursive predicate in scope
(one can nest ŒºÀ¢ an arbitrary number of times).

The $Œî$ records when each recursive predicate is used (now or
later). It is represented by a list-like data structured indexed
by Œì to ensure they have the same length, with $‚àÖ$ as the empty list
and $\textsf{cons}$ to add an element to the front of a list.
\textsf{SetÀ¢} is a record whose field \textsf{\#} is a
function from a tuple of step-indexed predicates to \textsf{Set·µí}.
(These tuples are structured like cons-lists with the
always-true predicate $\mathsf{tt}·µñ$ playing the role of nil.)
From the client's perspective, use the ``s'' connectives when
writing formulas under a Œº·µí and use the ``o'' connectives
otherwise. During this work we found that the ``s'' versus ``o''
distinction created unnecessary complexity for the client and have
developed a new version of the SIL (file \texttt{StepIndexedLogic2.lagda})
that has one version of each logical connective.

The majority of the lines of code in the SIL library are dedicated to
proving the \textsf{fixpoint·µí} theorem, which states that a recursive
predicate is equivalent to one unrolling of itself. The proof of
\textsf{fixpoint·µí} is an adaptation of the fixpoint theorem of Appel
and McAllester~\cite{Appel:2001aa}.

\begin{code}
_ : ‚àÄ(A : Set) (P : A ‚Üí SetÀ¢ (A ‚à∑ []) (cons Later ‚àÖ)) (a : A)
    ‚Üí Œº·µí P a ‚â°·µí # (P a) (Œº·µí P , tt·µñ)
_ = Œª A P a ‚Üí fixpoint·µí P a
\end{code}


\section{A Logical Relation for Precision}
\label{sec:log-rel}

\begin{code}[hide]
data Dir : Set where
  ‚âº : Dir
  ‚âΩ : Dir
\end{code}

To define a logical relation for precision, we adapt the logical
relation of New~\cite{New:2020ab}, which used explicit step indexing,
into the Step-Indexed Logic. The logical relation has two directions
(of type \textsf{Dir}): the ‚âº direction requires the more-precise term
to simulate the less-precise term whereas the ‚âΩ direction requires the
less-precise term to simulate the more-precise.  % In addition, the
logical relation consists of mutually-recursive relations on both
terms and values. SIL does not directly support mutual recursion, but
it can be expressed by combining the two relations into a single
relation whose input is a disjoint sum.  The formula for expressing
membership in these recursive relations is verbose, so we define the
below shorthands. Note that these shorthands are only intended for use
inside the definition of the logical relation.

\begin{code}
LR-type : Set
LR-type = (Prec √ó Dir √ó Term √ó Term) ‚äé (Prec √ó Dir √ó Term √ó Term)

LR-ctx : List Set
LR-ctx = LR-type ‚à∑ []

_‚à£_À¢‚äë·¥∏·¥ø‚Çú_‚¶Ç_ : Dir ‚Üí Term ‚Üí Term ‚Üí ‚àÄ{A}{A‚Ä≤} (c : A ‚äë A‚Ä≤) ‚Üí SetÀ¢ LR-ctx (cons Now ‚àÖ)
dir ‚à£ M À¢‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç c = (inj‚ÇÇ ((_ , _ , c) , dir , M , M‚Ä≤)) ‚àà zeroÀ¢

_‚à£_À¢‚äë·¥∏·¥ø·µ•_‚¶Ç_ : Dir ‚Üí Term ‚Üí Term ‚Üí ‚àÄ{A}{A‚Ä≤} (c : A ‚äë A‚Ä≤) ‚Üí SetÀ¢ LR-ctx (cons Now ‚àÖ)
dir ‚à£ V À¢‚äë·¥∏·¥ø·µ• V‚Ä≤ ‚¶Ç c = (inj‚ÇÅ ((_ , _ , c) , dir , V , V‚Ä≤)) ‚àà zeroÀ¢
\end{code}
\begin{code}[hide]
instance
  TermInhabited : Inhabited Term
  TermInhabited = record { elt = ` 0 }
\end{code}

\begin{figure}[tbp]
\begin{code}
LR‚Çú : Prec ‚Üí Dir ‚Üí Term ‚Üí Term ‚Üí SetÀ¢ LR-ctx (cons Later ‚àÖ)
LR·µ• : Prec ‚Üí Dir ‚Üí Term ‚Üí Term ‚Üí SetÀ¢ LR-ctx (cons Later ‚àÖ)

LR‚Çú (A , A‚Ä≤ , c) ‚âº M M‚Ä≤ =
   (‚àÉÀ¢[ N ] (M ‚ü∂ N)À¢ √óÀ¢ ‚ñ∑À¢ (‚âº ‚à£ N À¢‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç c))
   ‚äéÀ¢ (M‚Ä≤ ‚Ü† blame)À¢
   ‚äéÀ¢ ((Value M)À¢ √óÀ¢ (‚àÉÀ¢[ V‚Ä≤ ] (M‚Ä≤ ‚Ü† V‚Ä≤)À¢ √óÀ¢ (Value V‚Ä≤)À¢ √óÀ¢ (LR·µ• (_ , _ , c) ‚âº M V‚Ä≤)))
LR‚Çú (A , A‚Ä≤ , c) ‚âΩ M M‚Ä≤ =
   (‚àÉÀ¢[ N‚Ä≤ ] (M‚Ä≤ ‚ü∂ N‚Ä≤)À¢ √óÀ¢ ‚ñ∑À¢ (‚âΩ ‚à£ M À¢‚äë·¥∏·¥ø‚Çú N‚Ä≤ ‚¶Ç c))
   ‚äéÀ¢ (Blame M‚Ä≤)À¢
   ‚äéÀ¢ ((Value M‚Ä≤)À¢ √óÀ¢ (‚àÉÀ¢[ V ] (M ‚Ü† V)À¢ √óÀ¢ (Value V)À¢ √óÀ¢ (LR·µ• (_ , _ , c) ‚âΩ V M‚Ä≤)))

LR·µ• (.($‚Çú Œπ) , .($‚Çú Œπ) , base‚äë{Œπ}) dir ($ c) ($ c‚Ä≤) = (c ‚â° c‚Ä≤) À¢
LR·µ• (.($‚Çú Œπ) , .($‚Çú Œπ) , base‚äë{Œπ}) dir V V‚Ä≤ = ‚ä• À¢
LR·µ• (.(A ‚áí B) , .(A‚Ä≤ ‚áí B‚Ä≤) , fun‚äë{A}{B}{A‚Ä≤}{B‚Ä≤} A‚äëA‚Ä≤ B‚äëB‚Ä≤) dir (∆õ N)(∆õ N‚Ä≤) =
    ‚àÄÀ¢[ W ] ‚àÄÀ¢[ W‚Ä≤ ] ‚ñ∑À¢ (dir ‚à£ W À¢‚äë·¥∏·¥ø·µ• W‚Ä≤ ‚¶Ç A‚äëA‚Ä≤)
                  ‚ÜíÀ¢ ‚ñ∑À¢ (dir ‚à£ (N [ W ]) À¢‚äë·¥∏·¥ø‚Çú (N‚Ä≤ [ W‚Ä≤ ]) ‚¶Ç B‚äëB‚Ä≤) 
LR·µ• (.(A ‚áí B) , .(A‚Ä≤ ‚áí B‚Ä≤) , fun‚äë{A}{B}{A‚Ä≤}{B‚Ä≤} A‚äëA‚Ä≤ B‚äëB‚Ä≤) dir V V‚Ä≤ = ‚ä• À¢
LR·µ• (.‚òÖ , .‚òÖ , unk‚äëunk) dir (V ‚ü® G !‚ü©) (V‚Ä≤ ‚ü® H !‚ü©)
    with G ‚â°·µç H
... | yes refl = (Value V)À¢ √óÀ¢ (Value V‚Ä≤)À¢ √óÀ¢ (‚ñ∑À¢ (dir ‚à£ V À¢‚äë·¥∏·¥ø·µ• V‚Ä≤ ‚¶Ç Refl‚äë{‚åà G ‚åâ}))
... | no neq = ‚ä• À¢
LR·µ• (.‚òÖ , .‚òÖ , unk‚äëunk) dir V V‚Ä≤ = ‚ä• À¢
LR·µ• (.‚òÖ , .A‚Ä≤ , unk‚äë{H}{A‚Ä≤} d) ‚âº (V ‚ü® G !‚ü©) V‚Ä≤
    with G ‚â°·µç H
... | yes refl = (Value V)À¢ √óÀ¢ (Value V‚Ä≤)À¢ √óÀ¢ ‚ñ∑À¢ (‚âº ‚à£ V À¢‚äë·¥∏·¥ø·µ• V‚Ä≤ ‚¶Ç d)
... | no neq = ‚ä• À¢
LR·µ• (.‚òÖ , .A‚Ä≤ , unk‚äë{H}{A‚Ä≤} d) ‚âΩ (V ‚ü® G !‚ü©) V‚Ä≤
    with G ‚â°·µç H
... | yes refl = (Value V)À¢ √óÀ¢ (Value V‚Ä≤)À¢ √óÀ¢ (LR·µ• (‚åà G ‚åâ , A‚Ä≤ , d) ‚âΩ V V‚Ä≤)
... | no neq = ‚ä• À¢
LR·µ• (‚òÖ , .A‚Ä≤ , unk‚äë{H}{A‚Ä≤} d) dir V V‚Ä≤ = ‚ä• À¢
\end{code}

\caption{Logical Relation for Precision on Terms $\mathsf{LR}_t$
  and Values $\mathsf{LR}_v$}
\label{fig:log-rel-precision}
\end{figure}

The logical relation is defined in Figure~\ref{fig:log-rel-precision}
and explained in the following paragraphs.  The definition of the
logical relation for terms is based on the requirements of the gradual
guarantee, but it only talks about one step at a time of the term
begin simulated. In the ‚âº direction, the first clause says that the
less-precise $M$ takes a step to $N$ and that $N$ is related to $M‚Ä≤$
at one tick later in time. The second clause allows the more-precise
$M‚Ä≤$ to reduce to an error. The third clause says that the
less-precise $M$ is already a value, and requires $M‚Ä≤$ to reduce to a
value that is related at the current time to $M$. The other direction
‚âΩ is defined in a similar way, but with the more precise term $M‚Ä≤$
taking one step at a time.

The definition of the logical relation for values is by recursion on
the precision relation and by cases on the values and their types.
When both values are of the same base type ($\mathsf{base}‚äë$), they
are related if they are identical constants.  When the values are of
function type ($\mathsf{fun}‚äë$), then they are related if they are
both lambda abstractions that, when later applied to related
arguments, behave in a related way. When the values are both of unkown
type ($\mathsf{unk‚äëunk}$), then they are related if they are both
injections from the same ground type and the underlying values are
related one step later. If the less-precise value is of unknown type
but the more-precise value is not ($\mathsf{unk‚äë}$), then they are
related if (1) the less-precise value is an injection and (2) the
ground type of the injection is less-precise than the type of the
more-precise value. Furthermore, for direction ‚âº, (3a) the underlying
value of the injection is related one step later to the more-precise
value. For direction ‚âΩ, (3b) the underlying value of the injection is
related now to the more-precise value. Note that the recursive call
to $\mathsf{LR·µ•}$ is fine from a termination perspective because
argument $d$ is a subterm of $\mathsf{unk‚äë}\,d$. This is why
the $\mathsf{unk‚äë}$ rule needs to be recursive, with the
premise $‚åà G ‚åâ ‚äë B$.

The following definitions combine the LR·µ• and LR‚Çú functions into a
single function, pre-LR‚Çú‚äéLR·µ•, and than applies the Œº·µí operator to
produce the recursive relation LR‚Çú‚äéLR·µ•. Finally, we define some
shorthand for the logical relation on values, written ‚äë·¥∏·¥ø·µ•, and the
logical relation on terms, ‚äë·¥∏·¥ø‚Çú.

\begin{code}
pre-LR‚Çú‚äéLR·µ• : LR-type ‚Üí SetÀ¢ LR-ctx (cons Later ‚àÖ)
pre-LR‚Çú‚äéLR·µ• (inj‚ÇÅ (c , dir , V , V‚Ä≤)) = LR·µ• c dir V V‚Ä≤
pre-LR‚Çú‚äéLR·µ• (inj‚ÇÇ (c , dir , M , M‚Ä≤)) = LR‚Çú c dir M M‚Ä≤

LR‚Çú‚äéLR·µ• : LR-type ‚Üí Set·µí
LR‚Çú‚äéLR·µ• X = Œº·µí pre-LR‚Çú‚äéLR·µ• X

_‚à£_‚äë·¥∏·¥ø·µ•_‚¶Ç_ : Dir ‚Üí Term ‚Üí Term ‚Üí ‚àÄ{A A‚Ä≤} ‚Üí A ‚äë A‚Ä≤ ‚Üí Set·µí
dir ‚à£ V ‚äë·¥∏·¥ø·µ• V‚Ä≤ ‚¶Ç A‚äëA‚Ä≤ = LR‚Çú‚äéLR·µ• (inj‚ÇÅ ((_ , _ , A‚äëA‚Ä≤) , dir , V , V‚Ä≤))

_‚à£_‚äë·¥∏·¥ø‚Çú_‚¶Ç_ : Dir ‚Üí Term ‚Üí Term ‚Üí ‚àÄ{A A‚Ä≤} ‚Üí A ‚äë A‚Ä≤ ‚Üí Set·µí
dir ‚à£ M ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤ = LR‚Çú‚äéLR·µ• (inj‚ÇÇ ((_ , _ , A‚äëA‚Ä≤) , dir , M , M‚Ä≤))

_‚äë·¥∏·¥ø‚Çú_‚¶Ç_ : Term ‚Üí Term ‚Üí ‚àÄ{A A‚Ä≤} ‚Üí A ‚äë A‚Ä≤ ‚Üí Set·µí
M ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤ = (‚âº ‚à£ M ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤) √ó·µí (‚âΩ ‚à£ M ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤)
\end{code}

The relations that we have defined so far, ‚äë·¥∏·¥ø·µ• and ‚äë·¥∏·¥ø‚Çú, only apply
to closed terms, that is, terms with no free variables.  We also need
to relate open terms. The standard way to do that is to apply two
substitutions to the two terms, replacing each free variable with
related values. We relate a pair of substitutions Œ≥ and Œ≥‚Ä≤ with the
following definition, which says that the substitutions must be
point-wise related using the logical relation for values.

\begin{code}
_‚à£_‚ä®_‚äë·¥∏·¥ø_ : (Œì : List Prec) ‚Üí Dir ‚Üí Subst ‚Üí Subst ‚Üí List Set·µí
[] ‚à£ dir ‚ä® Œ≥ ‚äë·¥∏·¥ø Œ≥‚Ä≤ = []
((_ , _ , A‚äëA‚Ä≤) ‚à∑ Œì) ‚à£ dir ‚ä® Œ≥ ‚äë·¥∏·¥ø Œ≥‚Ä≤ =
    (dir ‚à£ (Œ≥ 0) ‚äë·¥∏·¥ø·µ• (Œ≥‚Ä≤ 0) ‚¶Ç A‚äëA‚Ä≤) ‚à∑ (Œì ‚à£ dir ‚ä® (Œª x ‚Üí Œ≥ (suc x)) ‚äë·¥∏·¥ø (Œª x ‚Üí Œ≥‚Ä≤ (suc x)))
\end{code}

We then define two open terms $M$ and $M‚Ä≤$ to be logically related
if there are a pair of related substitutions $Œ≥$ and $Œ≥‚Ä≤$ such that
applying them to $M$ and $M‚Ä≤$ produces related terms.

\begin{code}
_‚à£_‚ä®_‚äë·¥∏·¥ø_‚¶Ç_ : List Prec ‚Üí Dir ‚Üí Term ‚Üí Term ‚Üí Prec ‚Üí Set
Œì ‚à£ dir ‚ä® M ‚äë·¥∏·¥ø M‚Ä≤ ‚¶Ç (_ , _ , A‚äëA‚Ä≤) = ‚àÄ (Œ≥ Œ≥‚Ä≤ : Subst)
   ‚Üí (Œì ‚à£ dir ‚ä® Œ≥ ‚äë·¥∏·¥ø Œ≥‚Ä≤) ‚ä¢·µí dir ‚à£ (‚ü™ Œ≥ ‚ü´ M) ‚äë·¥∏·¥ø‚Çú (‚ü™ Œ≥‚Ä≤ ‚ü´ M‚Ä≤) ‚¶Ç A‚äëA‚Ä≤
\end{code}

\noindent We use the following notation for the conjunction of the two
directions and define the \textsf{proj} function for accessing each
direction.

\begin{code}
_‚ä®_‚äë·¥∏·¥ø_‚¶Ç_ : List Prec ‚Üí Term ‚Üí Term ‚Üí Prec ‚Üí Set
Œì ‚ä® M ‚äë·¥∏·¥ø M‚Ä≤ ‚¶Ç c = (Œì ‚à£ ‚âº ‚ä® M ‚äë·¥∏·¥ø M‚Ä≤ ‚¶Ç c) √ó (Œì ‚à£ ‚âΩ ‚ä® M ‚äë·¥∏·¥ø M‚Ä≤ ‚¶Ç c)

proj : ‚àÄ {Œì}{c} ‚Üí (dir : Dir) ‚Üí (M M‚Ä≤ : Term) ‚Üí Œì ‚ä® M ‚äë·¥∏·¥ø M‚Ä≤ ‚¶Ç c ‚Üí Œì ‚à£ dir ‚ä® M ‚äë·¥∏·¥ø M‚Ä≤ ‚¶Ç c
proj ‚âº M M‚Ä≤ M‚äëM‚Ä≤ = proj‚ÇÅ M‚äëM‚Ä≤
proj ‚âΩ M M‚Ä≤ M‚äëM‚Ä≤ = proj‚ÇÇ M‚äëM‚Ä≤
\end{code}

\begin{code}[hide]
LR‚Çú-def : ‚àÄ{A}{A‚Ä≤} ‚Üí (A‚äëA‚Ä≤ : A ‚äë A‚Ä≤) ‚Üí Dir ‚Üí Term ‚Üí Term ‚Üí Set·µí
LR‚Çú-def A‚äëA‚Ä≤ ‚âº M M‚Ä≤ =
   (‚àÉ·µí[ N ] (M ‚ü∂ N)·µí √ó·µí ‚ñ∑·µí (‚âº ‚à£ N ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤))
   ‚äé·µí (M‚Ä≤ ‚Ü† blame)·µí
   ‚äé·µí ((Value M)·µí √ó·µí (‚àÉ·µí[ V‚Ä≤ ] (M‚Ä≤ ‚Ü† V‚Ä≤)·µí √ó·µí (Value V‚Ä≤)·µí √ó·µí (‚âº ‚à£ M ‚äë·¥∏·¥ø·µ• V‚Ä≤ ‚¶Ç A‚äëA‚Ä≤)))
LR‚Çú-def A‚äëA‚Ä≤ ‚âΩ M M‚Ä≤ =
   (‚àÉ·µí[ N‚Ä≤ ] (M‚Ä≤ ‚ü∂ N‚Ä≤)·µí √ó·µí ‚ñ∑·µí (‚âΩ ‚à£ M ‚äë·¥∏·¥ø‚Çú N‚Ä≤ ‚¶Ç A‚äëA‚Ä≤))
   ‚äé·µí (Blame M‚Ä≤)·µí
   ‚äé·µí ((Value M‚Ä≤)·µí √ó·µí (‚àÉ·µí[ V ] (M ‚Ü† V)·µí √ó·µí (Value V)·µí √ó·µí (‚âΩ ‚à£ V ‚äë·¥∏·¥ø·µ• M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤)))
\end{code}
\begin{code}[hide]
LR‚Çú-stmt : ‚àÄ{A}{A‚Ä≤}{A‚äëA‚Ä≤ : A ‚äë A‚Ä≤}{dir}{M}{M‚Ä≤}
   ‚Üí dir ‚à£ M ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤ ‚â°·µí LR‚Çú-def A‚äëA‚Ä≤ dir M M‚Ä≤
\end{code}
\begin{code}[hide]
LR‚Çú-stmt {A}{A‚Ä≤}{A‚äëA‚Ä≤}{dir}{M}{M‚Ä≤} =
  dir ‚à£ M ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤                   ‚©¶‚ü® ‚â°·µí-refl refl ‚ü©
  Œº·µí pre-LR‚Çú‚äéLR·µ• (X‚ÇÇ dir)                  ‚©¶‚ü® fixpoint·µí pre-LR‚Çú‚äéLR·µ• (X‚ÇÇ dir) ‚ü©
  # (pre-LR‚Çú‚äéLR·µ• (X‚ÇÇ dir)) (LR‚Çú‚äéLR·µ• , tt·µñ) ‚©¶‚ü® EQ{dir} ‚ü©
  LR‚Çú-def A‚äëA‚Ä≤ dir M M‚Ä≤                    ‚àé
  where
  c = (A , A‚Ä≤ , A‚äëA‚Ä≤)
  X‚ÇÅ : Dir ‚Üí LR-type
  X‚ÇÅ = Œª dir ‚Üí inj‚ÇÅ (c , dir , M , M‚Ä≤)
  X‚ÇÇ = Œª dir ‚Üí inj‚ÇÇ (c , dir , M , M‚Ä≤)
  EQ : ‚àÄ{dir} ‚Üí # (pre-LR‚Çú‚äéLR·µ• (X‚ÇÇ dir)) (LR‚Çú‚äéLR·µ• , tt·µñ) ‚â°·µí LR‚Çú-def A‚äëA‚Ä≤ dir M M‚Ä≤
  EQ {‚âº} = cong-‚äé·µí (‚â°·µí-refl refl) (cong-‚äé·µí (‚â°·µí-refl refl) (cong-√ó·µí (‚â°·µí-refl refl) 
             (cong-‚àÉ Œª V‚Ä≤ ‚Üí cong-√ó·µí (‚â°·µí-refl refl) (cong-√ó·µí (‚â°·µí-refl refl)
              ((‚â°·µí-sym (fixpoint·µí pre-LR‚Çú‚äéLR·µ• (inj‚ÇÅ (c , ‚âº , M , V‚Ä≤)))))))))
  EQ {‚âΩ} = cong-‚äé·µí (‚â°·µí-refl refl) (cong-‚äé·µí (‚â°·µí-refl refl)
            (cong-√ó·µí (‚â°·µí-refl refl) (cong-‚àÉ Œª V ‚Üí cong-√ó·µí (‚â°·µí-refl refl)
              (cong-√ó·µí (‚â°·µí-refl refl)
               (‚â°·µí-sym (fixpoint·µí pre-LR‚Çú‚äéLR·µ• (inj‚ÇÅ (c , ‚âΩ , V , M‚Ä≤))))))))
\end{code}
\begin{code}[hide]
LR‚Çú-suc : ‚àÄ{A}{A‚Ä≤}{A‚äëA‚Ä≤ : A ‚äë A‚Ä≤}{dir}{M}{M‚Ä≤}{k}
  ‚Üí #(dir ‚à£ M ‚äë·¥∏·¥ø‚Çú M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤) (suc k) ‚áî #(LR‚Çú-def A‚äëA‚Ä≤ dir M M‚Ä≤) (suc k)
\end{code}
\begin{code}[hide]
LR‚Çú-suc {A}{A‚Ä≤}{A‚äëA‚Ä≤}{dir}{M}{M‚Ä≤}{k} =
   ‚â°·µí‚áí‚áî{k = suc k} (LR‚Çú-stmt{A}{A‚Ä≤}{A‚äëA‚Ä≤}{dir}{M}{M‚Ä≤})
\end{code}

The definition of ‚äë·¥∏·¥ø·µ• includes several clauses that ensured that the
related values are indeed syntactic values. Here we make use of that
to prove that indeed, logically related values are syntactic values.

\begin{code}[hide]
LR·µ•‚áíValue : ‚àÄ {k}{dir}{A}{A‚Ä≤} (A‚äëA‚Ä≤ : A ‚äë A‚Ä≤) M M‚Ä≤
   ‚Üí # (dir ‚à£ M ‚äë·¥∏·¥ø·µ• M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤) (suc k)  ‚Üí  Value M √ó Value M‚Ä≤
LR·µ•‚áíValue {k}{dir} unk‚äëunk (V ‚ü® G !‚ü©) (V‚Ä≤ ‚ü® H !‚ü©) ùí±MM‚Ä≤
    with G ‚â°·µç H
... | no neq = ‚ä•-elim ùí±MM‚Ä≤
... | yes refl
    with ùí±MM‚Ä≤
... | v , v‚Ä≤ , _ = (v ‚å© G ‚å™) , (v‚Ä≤ ‚å© G ‚å™)
LR·µ•‚áíValue {k}{‚âº} (unk‚äë{H}{A‚Ä≤} d) (V ‚ü® G !‚ü©) V‚Ä≤ ùí±VGV‚Ä≤
    with G ‚â°·µç H
... | yes refl
    with ùí±VGV‚Ä≤
... | v , v‚Ä≤ , _ = (v ‚å© _ ‚å™) , v‚Ä≤
LR·µ•‚áíValue {k}{‚âΩ} (unk‚äë{H}{A‚Ä≤} d) (V ‚ü® G !‚ü©) V‚Ä≤ ùí±VGV‚Ä≤
    with G ‚â°·µç H
... | yes refl
    with ùí±VGV‚Ä≤
... | v , v‚Ä≤ , _ = (v ‚å© _ ‚å™) , v‚Ä≤
LR·µ•‚áíValue {k}{dir} (unk‚äë{H}{A‚Ä≤} d) (V ‚ü® G !‚ü©) V‚Ä≤ ùí±VGV‚Ä≤
    | no neq = ‚ä•-elim ùí±VGV‚Ä≤
LR·µ•‚áíValue {k}{dir} (base‚äë{Œπ}) ($ c) ($ c‚Ä≤) refl = ($Ã¨ c) , ($Ã¨ c)
LR·µ•‚áíValue {k}{dir} (fun‚äë A‚äëA‚Ä≤ B‚äëB‚Ä≤) (∆õ N) (∆õ N‚Ä≤) ùí±VV‚Ä≤ =
    (∆õÃ¨ N) , (∆õÃ¨ N‚Ä≤)
\end{code}

\begin{code}
LR·µ•‚áíValue·µí : ‚àÄ {dir}{A}{A‚Ä≤}{ùí´} (A‚äëA‚Ä≤ : A ‚äë A‚Ä≤) M M‚Ä≤
   ‚Üí ùí´ ‚ä¢·µí (dir ‚à£ M ‚äë·¥∏·¥ø·µ• M‚Ä≤ ‚¶Ç A‚äëA‚Ä≤) ‚Üí ùí´ ‚ä¢·µí (Value M)·µí √ó·µí (Value M‚Ä≤)·µí
\end{code}
\begin{code}[hide]
LR·µ•‚áíValue·µí A‚äëA‚Ä≤ M M‚Ä≤ M‚äëM‚Ä≤ =
    ‚ä¢·µí-intro Œª { zero ùí´k ‚Üí tt , tt ;
                 (suc k) ùí´k ‚Üí LR·µ•‚áíValue A‚äëA‚Ä≤ M M‚Ä≤ (‚ä¢·µí-elim M‚äëM‚Ä≤ (suc k) ùí´k)}
\end{code}

If two values are related via ‚äë·¥∏·¥ø·µ•, then they are also related via
‚äë·¥∏·¥ø‚Çú.

\begin{code}[hide]
LR·µ•‚áíLR‚Çú-step : ‚àÄ{A}{A‚Ä≤}{A‚äëA‚Ä≤ : A ‚äë A‚Ä≤}{V V‚Ä≤}{dir}{k}
   ‚Üí #(dir ‚à£ V ‚äë·¥∏·¥ø·µ• V‚Ä≤ ‚¶Ç A‚äëA‚Ä≤) k  ‚Üí  #(dir ‚à£ V ‚äë·¥∏·¥ø‚Çú V‚Ä≤ ‚¶Ç A‚äëA‚Ä≤) k
LR·µ•‚áíLR‚Çú-step {A}{A‚Ä≤}{A‚äëA‚Ä≤}{V} {V‚Ä≤} {dir} {zero} ùí±VV‚Ä≤k =
   tz (dir ‚à£ V ‚äë·¥∏·¥ø‚Çú V‚Ä≤ ‚¶Ç A‚äëA‚Ä≤)
LR·µ•‚áíLR‚Çú-step {A}{A‚Ä≤}{A‚äëA‚Ä≤}{V} {V‚Ä≤} {‚âº} {suc k} ùí±VV‚Ä≤sk =
  ‚áî-fro (LR‚Çú-suc{dir = ‚âº})
  (let (v , v‚Ä≤) = LR·µ•‚áíValue A‚äëA‚Ä≤ V V‚Ä≤ ùí±VV‚Ä≤sk in
  (inj‚ÇÇ (inj‚ÇÇ (v , (V‚Ä≤ , (V‚Ä≤ END) , v‚Ä≤ , ùí±VV‚Ä≤sk)))))
LR·µ•‚áíLR‚Çú-step {A}{A‚Ä≤}{A‚äëA‚Ä≤}{V} {V‚Ä≤} {‚âΩ} {suc k} ùí±VV‚Ä≤sk =
  ‚áî-fro (LR‚Çú-suc{dir = ‚âΩ})
  (let (v , v‚Ä≤) = LR·µ•‚áíValue A‚äëA‚Ä≤ V V‚Ä≤ ùí±VV‚Ä≤sk in
  inj‚ÇÇ (inj‚ÇÇ (v‚Ä≤ , V , (V END) , v , ùí±VV‚Ä≤sk)))
\end{code}
\begin{code}
LR·µ•‚áíLR‚Çú : ‚àÄ{A}{A‚Ä≤}{A‚äëA‚Ä≤ : A ‚äë A‚Ä≤}{ùí´}{V V‚Ä≤}{dir}
   ‚Üí ùí´ ‚ä¢·µí dir ‚à£ V ‚äë·¥∏·¥ø·µ• V‚Ä≤ ‚¶Ç A‚äëA‚Ä≤  ‚Üí  ùí´ ‚ä¢·µí dir ‚à£ V ‚äë·¥∏·¥ø‚Çú V‚Ä≤ ‚¶Ç A‚äëA‚Ä≤
\end{code}
\begin{code}[hide]
LR·µ•‚áíLR‚Çú {A}{A‚Ä≤}{A‚äëA‚Ä≤}{ùí´}{V}{V‚Ä≤}{dir} ‚ä¢ùí±VV‚Ä≤ = ‚ä¢·µí-intro Œª k ùí´k ‚Üí
  LR·µ•‚áíLR‚Çú-step{V = V}{V‚Ä≤}{dir}{k} (‚ä¢·µí-elim ‚ä¢ùí±VV‚Ä≤ k ùí´k)
\end{code}


% LocalWords:  LogRel PeterFestschrift elim Bool proj inj tt Eq refl
% LocalWords:  sym cong subst trans Nullary Var Sig PeterCastCalculus
% LocalWords:  StepIndexedLogic infixr unk Prec dyn prec gnd var app
% LocalWords:  typeof lam SIL Agda LSLR de Bruijn fixpoint Appel Dir
% LocalWords:  McAllester LR ctx dir TermInhabited elt neq pre suc VV
% LocalWords:  def stmt VGV tz sk
